// Code generated by Wire. DO NOT EDIT.

//go:generate go run -mod=mod github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package main

import (
	"github.com/chaitin/panda-wiki/config"
	"github.com/chaitin/panda-wiki/handler"
	"github.com/chaitin/panda-wiki/handler/v1"
	"github.com/chaitin/panda-wiki/log"
	"github.com/chaitin/panda-wiki/middleware"
	"github.com/chaitin/panda-wiki/mq"
	cache2 "github.com/chaitin/panda-wiki/repo/cache"
	mq2 "github.com/chaitin/panda-wiki/repo/mq"
	pg2 "github.com/chaitin/panda-wiki/repo/pg"
	"github.com/chaitin/panda-wiki/server/http"
	"github.com/chaitin/panda-wiki/store/cache"
	"github.com/chaitin/panda-wiki/store/pg"
	"github.com/chaitin/panda-wiki/store/s3"
	"github.com/chaitin/panda-wiki/store/vector"
	"github.com/chaitin/panda-wiki/store/vector/embedding"
	"github.com/chaitin/panda-wiki/usecase"
)

// Injectors from wire.go:

func createApp() (*App, error) {
	configConfig, err := config.NewConfig()
	if err != nil {
		return nil, err
	}
	logger := log.NewLogger(configConfig)
	echo := http.NewEcho(logger, configConfig)
	httpServer := &http.HTTPServer{
		Echo: echo,
	}
	baseHandler := handler.NewBaseHandler(echo, logger, configConfig)
	db, err := pg.NewDB(configConfig)
	if err != nil {
		return nil, err
	}
	userRepository := pg2.NewUserRepository(db, logger)
	userUsecase, err := usecase.NewUserUsecase(userRepository, logger, configConfig)
	if err != nil {
		return nil, err
	}
	userAccessRepository := pg2.NewUserAccessRepository(db, logger)
	authMiddleware, err := middleware.NewAuthMiddleware(configConfig, logger, userAccessRepository)
	if err != nil {
		return nil, err
	}
	userHandler := v1.NewUserHandler(echo, baseHandler, logger, userUsecase, authMiddleware, configConfig)
	knowledgeBaseRepository := pg2.NewKnowledgeBaseRepository(db)
	embeddingEmbedding, err := embedding.NewEmbedding(configConfig, logger)
	if err != nil {
		return nil, err
	}
	vectorStore, err := vector.NewVectorStore(configConfig, logger, embeddingEmbedding)
	if err != nil {
		return nil, err
	}
	knowledgeBaseUsecase := usecase.NewKnowledgeBaseUsecase(knowledgeBaseRepository, vectorStore, logger)
	conversationRepository := pg2.NewConversationRepository(db)
	llmUsecase := usecase.NewLLMUsecase(configConfig, vectorStore, conversationRepository, logger)
	knowledgeBaseHandler := v1.NewKnowledgeBaseHandler(baseHandler, echo, knowledgeBaseUsecase, llmUsecase, authMiddleware, logger)
	docRepository := pg2.NewDocRepository(db, logger)
	mqProducer, err := mq.NewMQProducer(configConfig, logger)
	if err != nil {
		return nil, err
	}
	cacheCache, err := cache.NewCache(configConfig)
	if err != nil {
		return nil, err
	}
	expireTaskRepo := cache2.NewExpireTaskRepo(cacheCache)
	crawlRepository := mq2.NewCrawlRepository(mqProducer, expireTaskRepo, logger)
	vectorRepository := mq2.NewVectorRepository(mqProducer)
	minioClient, err := s3.NewMinioClient(configConfig)
	if err != nil {
		return nil, err
	}
	docUsecase := usecase.NewDocUsecase(docRepository, crawlRepository, vectorRepository, logger, minioClient)
	docHandler := v1.NewDocHandler(baseHandler, echo, docUsecase, authMiddleware, logger)
	appRepository := pg2.NewAppRepository(db)
	appUsecase := usecase.NewAppUsecase(appRepository, docRepository, conversationRepository, logger)
	modelRepository := pg2.NewModelRepository(db, logger)
	modelUsecase := usecase.NewModelUsecase(modelRepository, logger, configConfig)
	conversationUsecase := usecase.NewConversationUsecase(conversationRepository, docRepository, logger)
	appHandler := v1.NewAppHandler(echo, baseHandler, logger, authMiddleware, appUsecase, modelUsecase, conversationUsecase, configConfig)
	fileHandler := v1.NewFileHandler(echo, baseHandler, logger, authMiddleware, minioClient, configConfig)
	modelHandler := v1.NewModelHandler(echo, baseHandler, logger, authMiddleware, modelUsecase, llmUsecase)
	chatHandler := v1.NewChatHandler(echo, baseHandler, logger, authMiddleware, appUsecase, llmUsecase, conversationUsecase, modelUsecase, configConfig)
	conversationHandler := v1.NewConversationHandler(echo, baseHandler, logger, authMiddleware, conversationUsecase)
	apiHandlers := &v1.APIHandlers{
		UserHandler:          userHandler,
		KnowledgeBaseHandler: knowledgeBaseHandler,
		DocHandler:           docHandler,
		AppHandler:           appHandler,
		FileHandler:          fileHandler,
		ModelHandler:         modelHandler,
		ChatHandler:          chatHandler,
		ConversationHandler:  conversationHandler,
	}
	app := &App{
		HTTPServer: httpServer,
		Handlers:   apiHandlers,
		Config:     configConfig,
		Logger:     logger,
	}
	return app, nil
}

// wire.go:

type App struct {
	HTTPServer *http.HTTPServer
	Handlers   *v1.APIHandlers
	Config     *config.Config
	Logger     *log.Logger
}
